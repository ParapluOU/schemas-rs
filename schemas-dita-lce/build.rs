use std::env;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let schemas_dir = Path::new(&manifest_dir)
        .parent()
        .unwrap()
        .join("dita-lce/schemas");

    println!("cargo::rerun-if-changed={}", schemas_dir.display());

    let mut entries = Vec::new();

    // Walk the schemas directory
    for entry in WalkDir::new(&schemas_dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
    {
        let path = entry.path();

        // Only include schema-related files
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
        if !matches!(ext, "xsd" | "dtd" | "mod" | "ent" | "xml" | "txt" | "rng" | "rnc") {
            continue;
        }

        // Get relative path from schemas dir
        let rel_path = path
            .strip_prefix(&schemas_dir)
            .unwrap()
            .to_string_lossy()
            .replace('\\', "/");

        let abs_path = path.to_string_lossy().replace('\\', "/");

        entries.push((rel_path, abs_path));
    }

    // Sort for deterministic output
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the Rust code
    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n\n");
    code.push_str("pub static SCHEMA_FILES: &[schemas_core::SchemaFile] = &[\n");

    for (rel_path, abs_path) in &entries {
        code.push_str(&format!(
            "    schemas_core::SchemaFile::new({:?}, include_bytes!({:?})),\n",
            rel_path, abs_path
        ));
    }

    code.push_str("];\n");

    let out_path = Path::new(&out_dir).join("generated_schemas.rs");
    fs::write(&out_path, code).expect("Failed to write generated file");
}
